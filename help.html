<html><head></head><head></head><head></head><head></head><body><div id="contents"><style type="text/css">ol{margin:0;padding:0}p{margin:0}.c1{padding-top:10.0pt;line-height:1.15;text-indent:0pt;direction:ltr;padding-bottom:2.0pt}.c0{color:#000000;font-style:italic;font-size:11pt;font-family:Arial}.c20{vertical-align:super;color:#000000;font-size:7.333333333333333pt;font-family:Arial}.c2{padding-left:0pt;line-height:1.15;direction:ltr;margin-left:36.0pt}.c5{color:#000000;font-size:10pt;font-family:Arial;font-weight:bold}.c14{padding-left:0pt;line-height:1.15;direction:ltr}.c19{color:#000000;font-size:24pt;font-family:Arial}.c10{color:#000000;font-size:14pt;font-family:Arial}.c9{color:#000000;font-size:12pt;font-family:Arial}.c3{color:#000000;font-size:11pt;font-family:Arial}.c4{line-height:1.15;text-indent:0pt;direction:ltr}.c16{padding-top:14.0pt;padding-bottom:4.0pt}.c13{padding-top:24.0pt;padding-bottom:6.0pt}.c11{padding-top:11.0pt;padding-bottom:2.0pt}.c18{padding-top:12.0pt;padding-bottom:2.0pt}.c15{font-style:italic}.c21{list-style-type:circle}.c8{font-weight:bold}.c6{list-style-type:disc}.c17{background-color:#ffffff}.c7{margin-left:36.0pt}.c12{margin-left:72.0pt}body{color:#000000;font-size:11pt;font-family:Arial}.heading1{font-size:24pt;font-weight:bold}.heading2{font-size:18pt;font-weight:bold}.heading3{font-size:14pt;font-weight:bold}.heading4{font-size:12pt;font-weight:bold}.heading5{font-size:11pt;font-weight:bold}.heading6{font-size:10pt;font-weight:bold}</style><p class="c4 c13 heading1"><a name="h.2npx0x-5cluqa"></a><span class="c8 c19">Faucet Networking Extension</span></p><p class="c4 c18 heading4"><a name="h.btsuzq-dcwhry"></a><span class="c9 c8">About handles</span></p><p class="c4"><span class="c3">Analogous to Game Maker’s built in data structure functions, this extension uses handles to allow games to refer to sockets, buffers and other objects.</span></p><p class="c4"><span class="c3">Passing an invalid handle to a function will generate reasonable behaviour. For example, socket functions will pretend that the handle belongs to a socket in error state, and reading the error string will return an appropriate message.</span></p><p class="c4 c18 heading4"><a name="h.fm64wq-wauw35"></a><span class="c9 c8">About integers and rounding</span></p><p class="c4"><span class="c3">For some function parameters, only integer values make sense. For example, you can’t read 2.5 bytes, or connect to port 91.6. In cases where integer values are expected, they are rounded toward zero (truncated) before use, except where otherwise noted. The most important exception are the write_xxx functions for appending values to a buffer or socket, those always round toward the nearest integer.</span></p><p class="c4"><span class="c3"> </span></p><p class="c4"><span class="c9 c8">Connecting and disconnecting</span></p><p class="c1 heading6"><a name="h.805c8pd2kwhv"></a><span class="c5">tcp_connect(server, port) : tcpSocket</span></p><p class="c4 c7"><span class="c0">server</span><span class="c3"> is a string containing an IPv4 or IPv6 address or a hostname.</span></p><p class="c4 c7"><span class="c0">port</span><span class="c3"> is an integer in the range of 1 to 65535.</span></p><p class="c4 c7"><span class="c3">The returned socket can instantly be used in sending and receiving operations and will buffer sent data internally until the connection attempt is actually done.</span></p><p class="c4 c7"><span class="c3">A failed connection attempt can be identified by querying socket_has_error() once socket_connecting() returns false.</span></p><p class="c1 heading6"><a name="h.5e7o3s-jg8m9v"></a><span class="c5">socket_connecting(socket) : bool</span></p><p class="c4 c7"><span class="c3">Returns true if the socket is currently performing a connection attempt.</span></p><p class="c1 heading6"><a name="h.y5vw2byy7deh"></a><span class="c5">socket_has_error(socket | acceptor) : bool</span></p><p class="c4 c7"><span class="c3">When this function returns true the socket or acceptor is no longer able to perform its function. </span></p><p class="c4 c7"><span class="c3">For a TCP socket, this means that it can no longer send or receive data over the network. Trying to send additional data is useless (but harmless), and trying to receive anything will fail as if there was simply no data available.</span></p><p class="c4 c7"><span class="c3">For an acceptor it means that no new connections will be accepted. </span></p><p class="c4 c7"><span class="c3">The function socket_error() can be used to get a description of the error.</span></p><p class="c1 heading6"><a name="h.a8kbg4-iwptr6"></a><span class="c5">tcp_listen(port) : acceptor</span></p><p class="c4 c7"><span class="c0">port</span><span class="c3"> is an integer in the range of 1 to 65535.</span></p><p class="c4 c7"><span class="c3">Create a new acceptor to listen for incoming TCP connections on the indicated port. Both IPv4 and IPv6 connections to that port will be accepted. If an error occurs, the returned acceptor will indicate the failure. Please note that acceptors will only flag an error if both IPv4 and IPv6 connections can&#39;t be accepted anymore.</span></p><p class="c1 heading6"><a name="h.4aqm7vxasch4"></a><span class="c5">socket_accept(acceptor) : socket | errorcode</span></p><p class="c4 c7"><span class="c3">Accept a connection from an acceptor. If a connection is available, a (non-negative) TCP socket handle is returned. If no connection is available, a negative value is returned.</span></p><p class="c1 heading6"><a name="h.vpmw1r-gfuw2k"></a><span class="c5">socket_destroy_abortive(socket | acceptor) : void</span><span class="c3"></span><span class="c5">socket_destroy(socket | acceptor) : void</span></p><p class="c4 c7"><span class="c3">Closes the connection and destroys the socket. All sockets and acceptors have to be destroyed, even if they are already closed or in an error state, to release the associated resources.</span></p><p class="c4 c7"><span class="c0">socket_destroy_abortive </span><span class="c3">will close the connection immediately without trying to send any remaining data (abortive close using RST). </span><span class="c0">socket_destroy</span><span class="c3"> will attempt to send all data from the sendbuffer before closing (graceful close with FIN). In general, use a graceful close if you are closing the connection because there is nothing left to send or receive, and use an abortive close if you want to cut off a connection. The remote socket will indicate an abortive close as an error. If the socket is already in error state, then the connection is already closed, so there is no difference between the two functions.</span></p><p class="c4 c7"><span class="c3">In either case the socket handle will become invalid immediately and shouldn’t be used again afterwards.</span></p><p class="c4 c7"><span class="c3">For acceptors, it doesn’t matter which of the functions you use.</span></p><p class="c4 c18 heading4"><a name="h.kc28ud-wxkl7r"></a><span class="c9 c8">Sending and receiving information</span></p><p class="c4"><span class="c3">To understand how sending and receiving work, you first need to know that a socket has two internal buffers: The send buffer and the receive buffer. To send data, you need to add data to the socket’s send buffer and then call socket_send(socket). When you receive data, it will be written to the receive buffer.</span></p><p class="c4"><span class="c3">To access these buffers, you can use some of the normal buffer functions described in the Buffers section and pass them a socket handle instead of a buffer handle. In general, buffer functions that read data will refer to the receive buffer, and those that write data will refer to the send buffer. However, not all buffer functions make sense for the internal buffers of sockets, so check the descriptions of the individual functions to find out more.</span></p><p class="c4"><span class="c3">If you need more flexibility, you can use write_buffer to copy existing normal buffers to the send buffer, or to copy the receive buffer into a normal buffer.</span></p><p class="c1 heading6"><a name="h.luwz8z-opvuet"></a><span class="c5">tcp_receive(tcpSocket, size) : bool</span></p><p class="c4 c7"><span class="c3">Try reading </span><span class="c0">size</span><span class="c3"> bytes into the socket’s receive buffer. The previous contents of the receive buffer will be discarded. If the requested number of bytes is not available, a receive operation is started in the background to read at least as many bytes as requested, so that calling this function again later can succeed.</span></p><p class="c4 c7"><span class="c3">Returns true if the operation was successful. The receive buffer now contains exactly the number of bytes requested. If false is returned, the receive buffer will be empty.</span></p><p class="c4 c7"><span class="c3">If </span><span class="c0">size</span><span class="c3"> is negative or far too large (&gt;=2</span><span class="c20">32</span><span class="c3">), the function will return false without starting a background read.</span></p><p class="c4 c7"><span class="c3">If the connection is closed and more bytes are requested than are remaining to be read, the requested number of bytes can never become available. In this case the socket will transition to an error state.</span></p><p class="c1 heading6"><a name="h.q0zjhy-p3pk5w"></a><span class="c5">tcp_receive_available(tcpSocket) : size</span></p><p class="c4 c7"><span class="c3">Read all data currently available from the socket into the socket’s receive buffer. The previous contents of the receive buffer will be discarded. The function returns the number of bytes read, which is the same as the new size of the receive buffer.</span></p><p class="c1 heading6"><a name="h.9f44dad5wc6q"></a><span class="c5">tcp_eof(socket) : bool</span></p><p class="c4 c7"><span class="c3">Determine if there is no more data to receive. This means that the connection is closed in the receiving direction, either because the sender has closed it or because of an error, and all internally buffered data has been received (though there might still be unread data in the receive buffer). In that case, attempting to receive any more data on this socket will cause the socket to report an error.</span></p><p class="c1 heading6"><a name="h.4f4ey3-wu0a8u"></a><span class="c5">socket_send(socket) : void</span></p><p class="c4 c7"><span class="c3">Try to send data from the internal sendbuffer out through the socket. If you call this function too often, it might result in many small TCP packets being sent, which causes a lot of overhead and thus needs more bandwidth. If you call it too seldom, the data will sit in the sendbuffer for a longer time before being sent, so you get larger delays. A good time to call this is right after you’re done writing things to the sendbuffer of this socket for this step.</span></p><p class="c1 heading6"><a name="h.aaq79f-lq7dpf"></a><span class="c5">socket_sendbuffer_size(socket) : size</span></p><p class="c4 c7"><span class="c3">How many bytes are in the sendbuffer?</span></p><p class="c4 c7"><span class="c3">If the connection can’t send data as fast as the application demands, the sendbuffer will grow. This function can be used to detect slow connections and reduce the data rate. However, the result should be taken with a large grain of salt. The number returned does not include data already queued for sending in the network layer, and this can be a lot of data (in the order of megabytes). If you send data in many small chunks though, there should be less of that queued data and you should see a growing backlog in the sendbuffer pretty quickly.</span></p><p class="c1 heading6"><a name="h.awda18-j52u5z"></a><span class="c5">socket_receivebuffer_size(socket) : size</span></p><p class="c4 c7"><span class="c3">Returns the ammount of data in the receive buffer, analogous to buffer_size for normal buffers. The reason why this is a seperate function is to avoid confusion, because buffer_size(socket) doesn’t make clear whether the send or receive buffer is meant, and the function would make sense for both.</span></p><p class="c1 heading6"><a name="h.a3co14-xfxbjr"></a><span class="c5">socket_sendbuffer_limit(socket, size) : void</span></p><p class="c4 c7"><span class="c3">Prevent the sendbuffer from growing larger than this value (in bytes). 0 means no limit. If the sendbuffer would exceed this capacity the connection will be closed and an appropriate error will be indicated. There is no default limit since a reasonable value depends heavily on the application. To prevent “out of memory” problems it is recommended to set this limit on every socket.</span></p><p class="c1 heading6"><a name="h.8fpuu2hj0ymo"></a><span class="c5">udp_send(buffer, host, port) : void</span></p><p class="c4 c7"><span class="c3">Warning: This function has been included for preliminary UDP support, to make it possible to port Gang Garrison 2 to this library. It might be changed or removed when a proper UDP api is designed.</span></p><p class="c4 c7"><span class="c0">host </span><span class="c3">is a string containing an IPv4 or IPv6 address or a hostname.</span></p><p class="c4 c7"><span class="c0">port</span><span class="c3"> is an integer in the range of 1 to 65535</span></p><p class="c4 c7"><span class="c3">Make sure that the buffer is smaller than the maximum UDP packet size (roughly 64kb).</span></p><p class="c4 c18 heading4"><a name="h.kfssdx1jyo1t"></a><span class="c9 c8">Buffers</span></p><p class="c4"><span class="c3">Buffers typically contain data that has been received or should be sent.</span></p><p class="c4"><span class="c3">Handing an invalid buffer handle to a buffer function will cause the function to behave as if it was called on a constantly empty buffer. Some of these functions will act on a socket’s send or receive buffer if a socket handle is passed to them. The parameter names socketReceiveBuf and socketSendBuf indicate which of the two buffers the parameter refers to.</span></p><p class="c1 heading6"><a name="h.b72mjj6monub"></a><span class="c5">buffer_create() : buffer</span></p><p class="c4 c7"><span class="c3">Create a new, empty buffer.</span></p><p class="c1 heading6"><a name="h.ov5tty14v6jl"></a><span class="c5">buffer_destroy(buffer) : void</span></p><p class="c4 c7"><span class="c3">Destroy a buffer and release its handle. This function should be called on all buffers that are no longer needed to release the memory allocated to them.</span></p><p class="c1 heading6"><a name="h.8jhl61lb4opo"></a><span class="c5">buffer_clear(buffer) : void</span></p><p class="c4 c7"><span class="c3">Remove all content from the buffer, so that it behaves exactly like a buffer that has only just been created.</span></p><p class="c1 heading6"><a name="h.9l9h1b-z2mhb0"></a><span class="c5">buffer_size(buffer) : size</span></p><p class="c4 c7"><span class="c3">Returns the number of bytes in the buffer.</span></p><p class="c1 heading6"><a name="h.kr5ioh65po94"></a><span class="c5">buffer_bytes_left(buffer) : size</span></p><p class="c4 c7"><span class="c3">Returns the number of bytes that can still be read from the buffer.</span></p><p class="c1 heading6"><a name="h.od8vx7qavmhn"></a><span class="c5">buffer_set_readpos(buffer, pos) : void</span></p><p class="c4 c7"><span class="c3">Set the read pointer of the buffer to a new position (given in bytes). The given position will be clipped to the beginning or the end of the buffer if it is below 0 or above buffer_size(buffer). There is no corresponding buffer_get_readpos(), if you really need this you can calculate it as buffer_size(buffer)-buffer_bytes_left(buffer).</span></p><p class="c1 heading6"><a name="h.kxf2kg-k35r5"></a><span class="c5">write_[xxx](buffer | socketSendBuf, real) : void</span></p><p class="c4 c7"><span class="c3">Append the given value to the end of the buffer, or to the socket’s send buffer. The following functions are supported:</span></p><p class="c4 c7"><span class="c3">write_ubyte                8 bit unsigned integer</span></p><p class="c4 c7"><span class="c3">write_byte                8 bit signed integer</span></p><p class="c4 c7"><span class="c3">write_ushort                16 bit unsigned integer</span></p><p class="c4 c7"><span class="c3">write_short                16 bit signed integer</span></p><p class="c4 c7"><span class="c3">write_uint                32 bit unsigned integer</span></p><p class="c4 c7"><span class="c3">write_int                32 bit signed integer</span></p><p class="c4 c7"><span class="c3">write_float                32 bit floating point value</span></p><p class="c4 c7"><span class="c3">write_double                64 bit floating point value</span></p><p class="c4 c7"><span class="c3">The value of the provided real will be clipped to fit the range of the target type. For example, attempting to write anything above 127 as a (signed) byte will always write 127.</span></p><p class="c4 c7"><span class="c3">When converting the real to an integer type, the value is rounded to the nearest integer, with the halfway point being rounded away from 0.</span></p><p class="c4 c7"><span class="c3">To give some examples of this: write_short(buffer, 42.5) and write_short(buffer, 43.499) will both write 43, and write_short(buffer, -2.5) will write -3.</span></p><p class="c1 heading6"><a name="h.ki70gl8vth6t"></a><span class="c5">write_string(buffer | socketSendBuf, string) : void</span></p><p class="c4 c7"><span class="c3">Append a string in Game Maker’s 8 bit character encoding to the buffer, or to the socket’s send buffer. This will only write the raw characters, no length information or delimiter is included, so you will want to do that yourself.</span></p><p class="c1 heading6"><a name="h.ki70gl8vth6t"></a><span class="c5">write_buffer(target, source) : void</span></p><p class="c4 c7"><span class="c3">Append entire </span><span class="c0">source </span><span class="c3">buffer to the end of </span><span class="c0">target</span><span class="c3">. Both </span><span class="c0">source </span><span class="c3">and </span><span class="c0">target </span><span class="c3">may be either sockets or buffers. If </span><span class="c0">target </span><span class="c3">is a socket, it refers to the socket’s send buffer. If </span><span class="c0">source </span><span class="c3">is a socket, it refers to the socket’s receive buffer. This operation doesn’t affect the buffers’ read positions.</span></p><p class="c1 heading6"><a name="h.a0wumrcn6cgi"></a><span class="c5">read_[xxx](buffer | socketReceiveBuf) : real</span></p><p class="c4 c7"><span class="c3">Read a value of the expected type from the buffer, starting at its current read position. The read position will be advanced to the next byte after the read value. If there are not enough bytes left in the buffer, the returned value is undefined and the read position is set to the end of the buffer. If the buffer does not exist, 0 is returned. See write_[xxx] for possible types.</span></p><p class="c1 heading6"><a name="h.nn056s5vkse0"></a><span class="c5">read_string(buffer | socketReceiveBuf, size) : string</span></p><p class="c4 c7"><span class="c3">Read the given number of characters from the buffer and return them as a string. The reading starts at the buffer’s current read position. The read position will be advanced to the next byte after the read characters. If there are not enough bytes left in the buffer, the returned string will be shorter than requested and the read position is set to the end of the buffer. If </span><span class="c0">size</span><span class="c3"> is negative, an empty string is returned and the buffer’s read position will be unchanged.</span></p><p class="c4 c18 heading4"><a name="h.odklus-ewfx01"></a><span class="c8 c9">Endianness and compatibility</span></p><p class="c4 c7"><span class="c3">Data is always sent over the network as a bunch of bytes. For data types that consist of several bytes (e.g. int), that creates the question in which order they are transmitted. Most networking applications use the big-endian format, where the most significant byte of an integer is sent first (we’ll get to floating point values further below.) This is also the default byte order for this extension. However, some applications use the little-endian format where the bytes are sent in the opposite order. Perhaps most important in the context of GM networking, 39dll uses little-endian. In order to support both formats, the functions in this chapter were introduced.</span></p><p class="c4 c7"><span class="c3">In this library, endianness is an attribute of buffers and sockets. Whenever you write a value to a buffer or socket, it will be converted to a sequence of bytes using the endianness set for this target. The endianness also determines how values are read. Buffers and strings are already sequences of bytes, so writing those is not affected by the endianness of the target.</span></p><p class="c4 c7"><span class="c3">The previous sentence is pretty important, so let’s consider what it means in practice: Setting a socket to little-endian does </span><span class="c0">not</span><span class="c3"> ensure everything sent or received through it will be little-endian - only values written/read </span><span class="c0">directly</span><span class="c3"> to/from the socket’s send and receive buffer will be converted. If you write your values to a big-endian buffer first and then write that to the little-endian socket, the data will still be sent as big-endian.</span></p><p class="c4 c7"><span class="c3">Another important point is about floating point values. First off, these are converted to the requested endianness as well. However, there are more uncertainties with floats and doubles than just the byte order, because they can have different formats on different kinds of computers, and there is no single exact standard that everyone uses. This library sends them in the native format used by x86 PCs, and you will not run into problems as long as you communicate with games on other PCs which also use this library. However, if you want to communicate with different software or different kinds of computers, using float and double might give you unexpected results.</span></p><p class="c1 heading6"><a name="h.bz9gcq-r4c8qc"></a><span class="c5">set_little_endian_global(bool) : void</span></p><p class="c4 c7"><span class="c3">If the parameter is true, all new buffers and sockets are created with little-endian byte order, if it is false they will use big-endian. Already created buffers and sockets are not affected. The default byte order is big-endian.</span></p><p class="c1 heading6"><a name="h.xkdnec-fwgwpj"></a><span class="c5">set_little_endian(buffer|socket, bool) : void</span></p><p class="c4 c7"><span class="c3">Set the socket or buffer to use little-endian (</span><span class="c0">bool</span><span class="c3">=true) or big-endian (</span><span class="c0">bool</span><span class="c3">=false) byte order.</span></p><p class="c4 c18 heading4"><a name="h.468xl-w3ctaz"></a><span class="c9 c8">Miscellaneous</span></p><p class="c1 heading6"><a name="h.aozkf7-ezsan3"></a><span class="c5">socket_error(socket | acceptor) : string</span></p><p class="c4 c7"><span class="c3">Returns a string description of the current error status. This function can return a message even if socket_has_error() returns false. This is particularly the case for acceptors, which can fail partially (for one protocol) but won’t flag an error while there’s still a usable protocol. For acceptors the error messages for all protocols are returned.</span></p><p class="c1 heading6"><a name="h.9sz20h-6snvaw"></a><span class="c5">socket_handle_io() : void</span></p><p class="c4 c7"><span class="c3">This function should be called once every step to allow the networking library to perform background tasks. There is usually no sense in calling this function more than once per step, because most networking functions will call it internally anyway, so if you are busy-waiting for e.g. a connection to be established, it will work as expected without having to call this function in your loop.</span></p><p class="c4 c7"><span class="c3">The function will probably be removed in the future, because once I get a grip on multithreading the background work will be performed by a worker thread.</span></p><p class="c1 heading6"><a name="h.dznitv-scvvuf"></a><span class="c5">debug_handles() : numHandles</span></p><p class="c4 c7"><span class="c3">Returns the number of valid handles. This can be used in debug output to find out if some part of your code is leaking buffer or socket handles.</span></p><p class="c4 c7"><span class="c3"> </span></p></div></body></html>